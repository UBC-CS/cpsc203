---
date: 2025-09-11
---

## Announcements {.smaller}

-   Setup instructions available.

-   Python resources posted to piazza.

-   First examlet signup available.

::: notes
**Summary**

In this introductory class, we use metaphors and abstractions to characterize problem decomposition, code as a communication mechanism, and computational efficiency.
We continue our exploration of the idea of elegance, making connections to problem solving and code.
Then, we learn a mechanism for measuring efficiency, and talk briefly about why it's important to consider.
The discussion about efficiency is followed by a diversion into colour representation.
Finally, we look at some code!
The day concludes with a sequence of Python examples designed to clear the cobwebs on lists -- our first data structure!
:::

## Learning outcomes

1.  Computers interpret electrical signals as bits, and bits can be used to represent numbers, and numbers can be used to represent colours, which suggests that we can represent virtually *anything*!

## Warm Up

Suppose we can knit 10^12^ stitches per second...

|            | 10        | 100       | 1000      | 10,000   | 10^12^   |
|------------|-----------|-----------|-----------|----------|----------|
| $n$        | 10^-11^s  | 10^-10^ s | 10^-9^ s  | 10^-8^ s | 1 s      |
| $n \log n$ | 10^-11^ s | 10^-9^ s  | 10^-8^ s  | 10^-7^ s | 40 s     |
| $n^2$      | 10^-10^ s | 10^-8^ s  | 10^-6^ s  | 10^-4^ s | 10^12^ s |
| $n^3$      | 10^-9^ s  | 10^-6^ s  | 10^-3^ s  | 1 s      | 10^24^ s |
| $2^n$      | 10^-9^ s  | 10^18^ s  | 10^289^ s |          |          |

The amount of computation we do inside our algorithm actually matters!

::: notes
Why does this matter?

Annotate:

1.  Each stitch takes a tiny tiny fraction of a second 1/10^12^ = 10^-12^ (fastest machine is 415 x 10^15^).
2.  $n$ is size parameter for our computation.
3.  $T(n)$ is the amount of time our computation takes.

Choose one to illustrate if our rag/data size is 1000, and we need to compute n^3^ steps/stitches (like knitting a cube!!), then the total time is 1000^3^/10^12^ = 10^-3^ a thousandth of a second.
Nbd.

BUT let's look at bigger data.
10^12^ (\~128gb pretty big) 10^12^ mm = 1M km, 384,400 km to the moon.
149M km to the sun.
So knitting something that big would take 10^12^ s = \~32000 years.
The sun will long since have burnt out by 10^18^ s

Punchline---we don't want to do $2^n$ amount of computation, and we need creative approaches for big data.

Recap---we've seen a problem whose size we characterize by $n^2$, we'll see problems whose time we characterize by $n$, for sure, and later in the term, we'll see a problem which is very simply stated, whose size we characterize by $2^n$.
üôÅ

NOTE: $\log$ is $\log_2$.
And $\log 1000 = 10$.
:::

# Representation

## Colour interpretation

What's your favorite colour?
Do you have a sense for *why* it's your favorite?
Does that colour influence your dress/decor/purchases?

Psychological: <https://www.buzzfeed.com/mermaidbarbie/which-color-truly-matches-your-personality-24h9koy69s>

Cultural: <https://en.wikipedia.org/wiki/Color_symbolism>

[]{.hexagon-red}[]{.hexagon-orange}[]{.hexagon-yellow}[]{.hexagon-green}[]{.hexagon-blue}[]{.hexagon-violet}

## {{< iconify fa6-solid comments >}} Your turn: Colour---cultural interpretations {.activity .smaller}

Activity---In pairs, choose a colour (primary or secondary) and find something in its cultural symbolism that surprises you.
Contradictions are especially interesting.
Report your findings to the class (briefly).

::::: columns
::: {.column width="50%"}
[]{.hexagon-red}

[]{.hexagon-orange}

[]{.hexagon-yellow}
:::

::: {.column width="50%"}
[]{.hexagon-green}

[]{.hexagon-blue}

[]{.hexagon-violet}
:::
:::::

{{< countdown minutes=5 >}}

::: notes
Big design implications for data visualization
:::

## Colour---representation

![](/images/ssd.jpg){.absolute top="0px" right="0px" width="30%" fig-alt="Close-up of a solid-state drive (SSD) circuit board showing memory chips and connectors."}

First, some general questions‚Ä¶

What does data look like to a computer?

\
\

Is that enough?

::: footer
<https://arstechnica.com/information-technology/2012/06/inside-the-ssd-revolution-how-solid-state-disks-really-work/2/>
:::

::: notes
1.  Positive and negative charges interpreted as 1 and 0.
2.  Binary digits = *bits*
:::

## Colour---representation

Can we use bits to represent integers?

|       |       |       |       |
|-------|-------|-------|-------|
| 3     | 1     | 5     | 7     |
| 10^3^ | 10^2^ | 10^1^ | 10^0^ |

|  |  |  |  |
|------------------|------------------|------------------|------------------|
| [10^3^]{.text-hidden} | [10^2^]{.text-hidden} | [10^1^]{.text-hidden} | [10^0^]{.text-hidden} |
| [2]{.text-hidden}^3^ | [2]{.text-hidden}^2^ | [2]{.text-hidden}^1^ | [2]{.text-hidden}^0^ |

::: notes
Talk about the BASE of the number.
:::

## Colour---representation

What's the highest number we can represent with 4 bits?

\
\

What's the highest number we can represent with 5 bits?

\
\

How many bits do we need to express 120?

\
\

::: notes
Can we represent any integer this way?
YES!
Until we run out of memory.
But we have more memory than we can even conceive of.

How does this help us with colour?
:::

## Colour---representation

Can we use integers to represent colours?

One way: RGB (red, green, blue), where each "component" is in range 0 through 255.

ex. (`255, 0, 127`) == [[]{.swatch-purple} []{.swatch-cyan} []{.swatch-lime} []{.swatch-pink} []{.swatch-apricot}]{style="position: relative; top: 11px;"}

Fun calculator for colour values: <https://colorizer.org>

How many bits for 256 values?
`4  5  6  7  8  9  10`

## Colour---representation

What colour is

::: small-font-size
\

`0 1 0 1 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1 1`

\
:::

Easier to read if we use *hexadecimal* representation:

Each component is represented by 2 hex digits `0123456789abcdef`

ex. `#674ea7` []{.swatch-purple} []{.swatch-cyan} []{.swatch-lime} []{.swatch-pink} []{.swatch-orange}

::: notes
Hex = base 16
:::

## Colour---representation (aside)

What do you observe about the following RGB colours?

| Red | Green | Blue |
|:---:|:-----:|:----:|
| 255 |   0   |  0   |
| 17  |   0   | 178  |
| 45  |   0   |  13  |
| 200 |   0   | 220  |
| 62  |   0   |  37  |
| 130 |   0   |  95  |

## colour and Code {.smaller}

Make the poppies pop!

![](/images/poppyfield.jpg){fig-alt="A field of red poppies."}

Examine each pixel.
If its red colour channel is high (over 200, say), then leave it as is.
Otherwise, change the pixel to grey by setting all 3 colour channels to the average of their original values.

## colour and Code

```{pyodide}
from typing import Tuple
import numpy as np
from skimage import io
import matplotlib.pyplot as plt

Pixel = Tuple[np.uint8, np.uint8, np.uint8]  # (r, g, b)

'''Input: Pixel p
   Output: Pixel
   Function: If the pixel has high red value, then don't change it, otherwise
   fade the pixel to grey.  Note, to grey a pixel, set all colour channels to
   the average of the 3.
'''
def boost_red_pixel(p: Pixel) -> Pixel:
    # setup -- extract the colour channels as ints
    red = int(p[0])
    green = int(p[1])
    blue = int(p[2])

    # compute grey 


    # conditionally change the pixel to grey


    # return updated pixel
    return Pixel((red, green, blue))

''' Input: np.ndarray representing an image
    Output: an np.ndarray representing an image
    Function: Create a new image by appling the boost_red_pixel 
    function to every pixel in the original, and saving the 
    result to the copy.
'''

def fancify(img: np.ndarray) -> np.ndarray:
    H, W = img.shape[:2] # grab the height and width of the image
    out = img.copy()     # write to a copy -- easy way to get the size right

    # traverse every pixel in the image and write to the copy!
    


    # return image with changed pixels
    return out

def main() -> None:
    
    img = io.imread('https://raw.githubusercontent.com/UBC-CS/cpsc203/refs/heads/main/images/poppyfield.jpg')[..., :3]     # read from website, keep first 3 channels (RGB)
    
    out = fancify(img)            # make a new fancy image

    plt.imshow(out)               # output the results
    plt.axis('off')
    plt.show()

main()
```

::: notes
``` python
from typing import Tuple
import numpy as np
from skimage import io
import matplotlib.pyplot as plt

Pixel = Tuple[np.uint8, np.uint8, np.uint8]  # (r, g, b)

'''Input: Pixel p
   Output: Pixel
   Function: If the pixel has high red value, then don't change it, otherwise
   fade the pixel to grey.  Note, to grey a pixel, set all colour channels to
   the average of the 3.
'''
def boost_red_pixel(p: Pixel) -> Pixel:
    # setup -- extract the colour channels as ints
    red = int(p[0])
    green = int(p[1])
    blue = int(p[2])
    # compute grey 
    grey = (red + green + blue)//3

    # conditionally change the pixel to grey
    if red < 200:
        red = green = blue = grey

    # return updated pixel
    return (red, green, blue)

def fancify(img: np.ndarray) -> np.ndarray:
    H, W = img.shape[:2] # grab the height and width of the image
    out = img.copy()     # write to a copy

    # traverse every pixel in the image and change it!
    for row in range(H):
        for col in range(W):
            out[row, col] = boost_red_pixel(img[row,col])

    # return image with changed pixels
    return out

def main() -> None:
    
    img = io.imread('https://raw.githubusercontent.com/UBC-CS/cpsc203/refs/heads/main/images/poppyfield.jpg')[..., :3]     # keep first 3 channels (RGB)
    
    out = fancify(img)
  
    plt.imshow(out)
    plt.axis('off')
    plt.show()
  
main()
```
:::