---
date: 2026-02-03
pyodide:
  packages:
    - pandas
    - matplotlib
---

## Announcements

## Today

* Warm Up: datetime
* From dictionaries to **DataFrames**
* Filtering, aggregating, and more — in one line!

## Warm Up {.smaller}

**`datetime`**: a Python library that simplifies date computation. 

**Objects we need**

* `date` — a calendar day (year-month-day)
* `timedelta` — a number of days you can add/subtract 

**Core calls**

* `today=date.today()`: today’s date 
* `today.weekday()`: an integer **0..6** with **Mon=0, ... , Sun=6**
* `today - timedelta(days=k)`: the date **k days earlier**

Ref: <https://docs.python.org/3/library/datetime.html>

::: notes
**Billboard constraint**
- The library expects **Saturday** chart dates. We need the **most recent Saturday** at or before today.
:::

## Last Saturday {.smaller}

Let $w =$ `today.weekday()` $\in \{0,\dots,6\}$ and note **Saturday $= 5$**.


::::: columns
:::: {.column width="60%"}


**offset:** How many days to step *back* to reach Saturday.

* If today is **Saturday** ($w=5$): offset $=0$
* If today is **Sunday** ($w=6$): offset $=1$
* If today is **Monday** ($w=0$): offset $=2$
* ...

$$
\texttt{offset} = (w - 5)\bmod 7
$$

$$
\texttt{lastSaturday} = \texttt{today} - \texttt{timedelta(days=offset)}.
$$

::::
:::: {.column width="20%"}

![](/images/clock7.svg){width="100%"}

::::
:::::

<!-- Inline SVG week strip (Mon=0 … Sun=6; Sat=5 highlighted) -->
<svg viewBox="0 0 820 120" width="90%" role="img" aria-label="Weekday indices Mon=0 ... Sun=6; Saturday=5">
  <style>
    .b { font: 600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Arial; }
    .d { font: 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Arial; }
  </style>
  <!-- boxes -->
  <g fill="#f7f7f7" stroke="#444">
    <rect x="10"  y="20" width="100" height="60" rx="10"/>
    <rect x="120" y="20" width="100" height="60" rx="10"/>
    <rect x="230" y="20" width="100" height="60" rx="10"/>
    <rect x="340" y="20" width="100" height="60" rx="10"/>
    <rect x="450" y="20" width="100" height="60" rx="10"/>
    <rect x="560" y="20" width="100" height="60" rx="10" fill="#fff8e1" stroke="#b8860b" stroke-width="2"/>
    <rect x="670" y="20" width="100" height="60" rx="10"/>
  </g>
  <!-- labels -->
  <g class="b" text-anchor="middle" fill="#111">
    <text x="60"  y="48">Mon</text><text x="60"  y="74" class="d">0</text>
    <text x="170" y="48">Tue</text><text x="170" y="74" class="d">1</text>
    <text x="280" y="48">Wed</text><text x="280" y="74" class="d">2</text>
    <text x="390" y="48">Thu</text><text x="390" y="74" class="d">3</text>
    <text x="500" y="48">Fri</text><text  x="500" y="74" class="d">4</text>
    <text x="610" y="48">Sat</text><text  x="610" y="74" class="d">5</text>
    <text x="720" y="48">Sun</text><text  x="720" y="74" class="d">6</text>
  </g>
</svg>

## Code 

``` {pyodide}
from datetime import date, timedelta

def getLastSaturday(day):
    w = day.weekday()                        # Mon=0, ..., Sat=5, Sun=6
    offset = (w - 5) % 7                     # days since the most recent Saturday
    return day - timedelta(days=offset)      # step back by that many days

today = date.today()
lastSatDate = getLastSaturday(today)
print(f"Last Saturday's date was: {lastSatDate}")

```


# Data Frames

## Last week: Lists of Dictionaries

``` {pyodide}
#| setup: true
#| exercise: billboard
import pandas as pd
df = pd.read_csv('https://raw.githubusercontent.com/UBC-CS/cpsc203/refs/heads/main/data/bill_2026-01-31.csv')
chartlist = df.to_dict('records')
```

We explored Billboard data using **loops**:

``` {pyodide}
#| exercise: billboard
# chartlist: list of song dictionaries
# Find artist with most songs
artist_counts = {}
for song in chartlist:
    artist = song['artist']
    if artist in artist_counts:
        artist_counts[artist] += 1
    else:
        artist_counts[artist] = 1

print(artist_counts)
```

This works, but it's verbose. Every question needed a loop!

## A Better Way: DataFrames

A **DataFrame** is a 2D table: rows = records, columns = attributes.

DataFrames have **built-in operations** for filtering, aggregating, and more.

``` {pyodide}
import pandas as pd
df = pd.read_csv('https://raw.githubusercontent.com/UBC-CS/cpsc203/refs/heads/main/data/bill_2026-01-31.csv')
df.head(10)
```


## pandas and data frames


`import pandas as pd`

Create a DataFrame from a list of dictionaries:

```python
df = pd.DataFrame(chartlist)
```

Or load from a CSV file:

```python
df = pd.read_csv('billboard.csv')
```


## The Payoff: One-Liners! {.smaller}

| Task | With loops | With DataFrames |
|------|------------|-----------------|
| Count new songs | 5+ lines | `df[df['isNew']].shape[0]` |
| Average peak | 4 lines | `df['peakPos'].mean()` |
| Filter long-running | 4 lines | `df[df['weeks'] > 10]` |
| Find biggest mover | 8+ lines | `df.loc[df['gradient'].abs().idxmax()]` |

## `.csv` files 

If our data is in a `.csv` file:

```python
df = pd.read_csv('billboard.csv')
```

`.csv` files have *attribute names* in row 1, and data beginning in row 2.

```default
title,artist,rank,last_week,...
Die With A Smile,Lady Gaga,1,1,...
APT.,Rose & Bruno Mars,2,2,...
```

``` {pyodide}
# What columns (attributes) do we have?
print(df.columns.tolist())
```


##  {background-iframe="https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf" background-interactive="true" data-menu-title="pandas cheat sheet"}

## Selecting rows {.smaller}

::::: columns
::: {.column width="30%"}
![](/images/pandas-subset-rows.png){fig-alt="pandas cheat sheet section on selecting rows in pandas data frames."}

:::

::: {.column width="70%"}

-   `df.nlargest(n, col)` — top n by column


``` {pyodide}
# Top 5 by weeks on chart
print(df.nlargest(5, 'weeks')[['title', 'weeks']])
```

-   `df[df[col] > val]` — filter by condition

``` {pyodide}
# Songs on chart more than 20 weeks
long_runners = df[df['weeks'] > 20]
print(long_runners[['title', 'weeks']])
```
:::
:::::

## Adding a column {.smaller}

::::: columns
::: {.column width="40%"}
-   `df['new_col'] = expression`

    Adds a column to the DataFrame containing the computed value for every row.

-   `df[df['new_col'] > val]`

    Filter rows by the new column.
:::

::: {.column width="60%"}
``` {pyodide}

# Add a "gradient" column 
df['gradient'] = df['last_week'] - df['rank']

# Find songs that rose more than 10 spots
risers = df[df['gradient'] > 10]
print(risers[['title', 'rank', 'last_week', 'gradient']])
```
:::
:::::

## Guided Demos

Let's work through some examples together before you try similar problems.

# Demo 1: Counting with a condition

## Demo: How many Taylor Swift songs? {.smaller}

::::: columns
::: {.column width="40%"}
**Goal:** Count songs by a specific artist.

**Strategy:**

1. Filter rows where artist contains "Taylor"
2. Count the resulting rows
:::

::: {.column width="60%"}
``` {pyodide}

# Filter for Taylor Swift
taylor = df[df['artist'].str.contains('Taylor')]
print(f"Taylor Swift has {len(taylor)} songs on the chart:")
print(taylor[['rank', 'title']])
```
:::
:::::

## Demo: How many songs at #1 peak? {.smaller}

::::: columns
::: {.column width="40%"}
**Goal:** Count songs that peaked at #1.

**Strategy:**

1. Filter where `peakPos == 1`
2. Count with `len()` or `.shape[0]`
:::

::: {.column width="60%"}
``` {pyodide}

# Songs that peaked at #1
peaked_at_one = df[df['peakPos'] == 1]
print(f"Songs that peaked at #1: {len(peaked_at_one)}")
print(peaked_at_one[['rank', 'title', 'peakPos']].head())
```
:::
:::::

# Demo 2: Aggregation (mean, max, min)

## Demo: Average weeks on chart {.smaller}

::::: columns
::: {.column width="40%"}
**Goal:** Find the average weeks on chart.

**Strategy:**

- Select a column: `df['weeks']`
- Apply aggregation: `.mean()`
:::

::: {.column width="60%"}
``` {pyodide}

avg_weeks = df['weeks'].mean()
print(f"Average weeks on chart: {avg_weeks:.1f}")

# Also useful: min, max, median
print(f"Min: {df['weeks'].min()}, Max: {df['weeks'].max()}")
```
:::
:::::

## Demo: Average weeks for top 10 only {.smaller}

::::: columns
::: {.column width="40%"}
**Goal:** Average weeks, but only for top 10 songs.

**Strategy:**

1. Filter first: `df[df['rank'] <= 10]`
2. Then aggregate: `['weeks'].mean()`
:::

::: {.column width="60%"}
``` {pyodide}

top10 = df[df['rank'] <= 10]
avg_weeks_top10 = top10['weeks'].mean()

print(f"Average weeks (all songs): {df['weeks'].mean():.1f}")
print(f"Average weeks (top 10): {avg_weeks_top10:.1f}")
```
:::
:::::

# Demo 3: Finding extremes with idxmax

## Demo: Longest-running song {.smaller}

::::: columns
::: {.column width="40%"}
**Goal:** Find the song with the most weeks on chart.

**Strategy:**

- `idxmax()` returns the **row index** of the maximum
- `df.loc[idx]` retrieves that row
:::

::: {.column width="60%"}
``` {pyodide}

# Find index of max weeks
idx = df['weeks'].idxmax()
longest = df.loc[idx]

print(f"Longest-running song:")
print(f"  {longest['title']} by {longest['artist']}")
print(f"  {longest['weeks']} weeks, currently #{longest['rank']}")
```
:::
:::::

## Demo: Biggest riser this week {.smaller}

::::: columns
::: {.column width="40%"}
**Goal:** Which song moved up the most?

**Problem:** New songs have `lastPos = 0` (they weren't on the chart last week).

**Strategy:**

1. Filter out new songs first
2. Compute change: `lastPos - rank`
3. Find max with `idxmax()`
:::

::: {.column width="60%"}
``` {pyodide}

# Exclude new songs (lastPos == 0 means "not on chart last week")
returning = df[df['lastPos'] > 0].copy()

# Positive = rose, negative = fell
returning['change'] = returning['lastPos'] - returning['rank']

# Find biggest riser
idx = returning['change'].idxmax()
riser = returning.loc[idx]
print(f"Biggest riser: {riser['title']}")
print(f"  #{riser['lastPos']} → #{riser['rank']} (up {riser['change']} spots)")
```
:::
:::::

## Handling special values {.smaller}

::::: columns
::: {.column width="50%"}
**The `lastPos = 0` problem**

New songs weren't on the chart last week, so `lastPos = 0`.

If we compute `change = lastPos - rank`:

- New song at #23: `0 - 23 = -23`
- Looks like it **fell** 23 spots!

**Solution:** Filter them out first, or use `isNew`.
:::

::: {.column width="50%"}
``` {pyodide}

# New songs have lastPos = 0
new_songs = df[df['lastPos'] == 0]
print("New songs (lastPos = 0):")
print(new_songs[['rank', 'title', 'lastPos', 'isNew']])
```
:::
:::::


## Let's Write Code {.activity}

Open CA5.1 Billboard, and load `STUDENT_nb.py`.

[PrairieLearn Activity](https://us.prairielearn.com/pl/course_instance/202804/assessment/2641273)


## Resources

<https://pymotw.com/2/datetime/>

<https://www.dataschool.io/best-python-pandas-resources/>

<https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf>

<https://queirozf.com/entries/pandas-dataframe-plot-examples-with-matplotlib-pyplot>




