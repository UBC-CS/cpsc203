---
date: 2026-02-12
pyodide:
  packages:
    - pandas
---

## Announcements

* Examlet 2 is happening now good luck!
* Project 1 due March 1

## Dictionaries

Dictionaries are Python's **key-value lookup** structure.

``` {pyodide}
# Creating a dictionary
suspect = {
    "name": "Prof. Histogram",
    "department": "Statistics",
    "alibi": "Was at faculty meeting",
    "motive": "Jealousy of the DataFrame's power"
}

print(suspect["name"])
print(suspect["alibi"])

# Add new key-value pair
suspect["last_seen"] = "Library, 8pm"

# Check if key exists
if "motive" in suspect:
    print("Motive found!")

# Get all keys
print(list(suspect.keys()))
```

## Beware: KeyError!

``` {pyodide}
# What happens if the key doesn't exist?
try:
    print(suspect["hobby"])
except KeyError as e:
    print(f"KeyError: {e} ‚Äî that key doesn't exist!")
```

``` {pyodide}
# Safe way to check first
if "hobby" in suspect:
    print(suspect["hobby"])
else:
    print("No hobby on file")
```

## Why Dictionaries?

**Lists:** Access by position (index)
```python
fruit = [("apple","red"), ("banana","yellow"), ("cherry","red")]
fruit[0], fruit[1], fruit[2]  # How do you look for "apple"?
```

**Dictionaries:** Access by meaningful key
```python
fruit = {"apple":"red", "banana":"yellow", "cherry":"red"}
fruit["apple"], fruit["banana"], fruit["cherry"]  # Self-documenting!
```

Dictionaries are also **fast** ‚Äî requires the same time whether there are 100 entries, or 100,000.

# Dictionary Patterns

## Pattern 0: Records

Alternative to a data frame or named tuple:

``` {pyodide}
# Security log: who entered which rooms
security_log = [
    {"person": "Prof. Histogram", "room": "Gallery A", "time": "7:00pm"},
    {"person": "Dr. Correlation", "room": "Gallery B", "time": "7:15pm"},
    {"person": "Prof. Histogram", "room": "Gallery B", "time": "7:30pm"},
    {"person": "Ms. Outlier", "room": "Gallery A", "time": "7:45pm"},
    {"person": "Dr. Correlation", "room": "Vault", "time": "8:00pm"},
    {"person": "Prof. Histogram", "room": "Vault", "time": "8:15pm"}
]
```


## Pattern 1: Membership

Find everyone who was in Gallery A *and* Gallery B.

``` {pyodide}
# Who was in Gallery A?
gallery_a_visitors = [log["______"] for log in ____________
                      if log["____"] == "Gallery A"]
print("Gallery A:", gallery_a_visitors)
# Who was in Gallery B?
```

## The Naive Approach: Check Every Pair

``` {pyodide}
# Check every person in A against every person in B
in_both = []
for person_a in gallery_a_visitors:      # Loop through A
    for person_b in gallery_b_visitors:  # Loop through B
        if person_a == person_b:
            in_both.append(person_a)
print("In both:", set(in_both))
```

This works... but what if the lists are LONG?

## The Problem with Nested Loops

![](../images/nested_loop_check.svg)

With 10 people in Gallery A and 12 in Gallery B:
**10 √ó 12 = 120 comparisons**

With 10,000 in each: **100,000,000 comparisons!**

## Pattern 1: Membership with a Dictionary

``` {pyodide}
from collections import defaultdict

# Step 1: Build a "seen in Gallery A" dictionary
in_gallery_a = defaultdict(bool)
for person in gallery_a_visitors:
    in_gallery_a[person] = True

print("Seen in Gallery A:", dict(in_gallery_a))
```

``` {pyodide}
# Step 2: Check who from Gallery B is also in the dict
suspects_both_rooms = []
for person in gallery_b_visitors:
    if in_gallery_a[person]:  # No KeyError thanks to defaultdict!
        suspects_both_rooms.append(person)

print("In BOTH rooms:", set(suspects_both_rooms))
```

## Why Is This Faster?

- **Step 1:** Look at each Gallery A person once ‚Üí 10 operations
- **Step 2:** Look at each Gallery B person once ‚Üí 12 operations
- **Total:** 10 + 12 = **22 operations** (not 120!)

Dictionary lookup is **instant** ‚Äî it doesn't matter how many keys are stored!

## Pattern 2: Counting Frequencies

**Use case:** Count how many times each item appears.

``` {pyodide}
from collections import Counter # specialized dictionary

cipher = "WKLV LV WKH FRGH: GLDJRQDO"

# Count letter frequencies using Counter
letters_only = [c for c in cipher if c.isalpha()]
letter_counts = Counter(letters_only)

print("Letter frequencies:", letter_counts)
print(f"Most common: {letter_counts.most_common(3)}")
```

## Pattern 3: Finding Complements

**Use case:** Find two numbers that add up to a target.

``` {pyodide}
from collections import defaultdict

numbers = [3, 7, 1, 9, 4, 6, 2]
target = 10

for n in numbers:
    for m in numbers:
        if n + m == target:
            print(f"Found pair: {m} + {n} = {target}")
```

Do you like this? 

## Pattern 3: Finding Complements, reprise

**Use case:** Find two numbers that add up to a target.

``` {pyodide}
from collections import defaultdict

numbers = [3, 7, 1, 9, 4, 6, 2]
target = 10

seen = defaultdict(bool)
for n in numbers:
    complement = target - n
    if seen[complement]:  # No KeyError with defaultdict!
        print(f"Found pair: {complement} + {n} = {target}")
    seen[n] = True
```

As we scan, we remember what we've seen ‚Äî and check if the complement exists!


## Pattern 4: Grouping by Category

**Use case:** Organize items into categories

``` {pyodide}
from collections import defaultdict

fruits = [
    ("apple", "red"),
    ("banana", "yellow"),
    ("cherry", "red"),
    ("lemon", "yellow"),
    ("grape", "purple")
]

by_color = defaultdict(list)  # Missing keys auto-create empty lists
for fruit, color in fruits:
    by_color[color].append(fruit)

print(dict(by_color))
```

## Grouping with Dictionaries

What if our items are dictionaries, not tuples?

``` {pyodide}
from collections import defaultdict

# Two example suspects
example_suspects = [
    {"name": "Prof. Histogram", "alibi": "faculty meeting"},
    {"name": "Mr. Regression", "alibi": "faculty meeting"},
]

by_alibi = defaultdict(list)
for suspect in example_suspects:
    by_alibi[suspect["alibi"]].append(suspect["name"])

print(dict(by_alibi))
```

Same pattern ‚Äî just access the key with `suspect["alibi"]` instead of unpacking a tuple!

## Pattern 5: Translation/Mapping

**Use case:** Convert values from one representation to another.

``` {pyodide}
from collections import defaultdict

word_to_emoji = defaultdict(str, {
    "sun": "‚òÄÔ∏è", "rain": "üåßÔ∏è", "cloud": "‚òÅÔ∏è",
    "happy": "üòä", "sad": "üò¢", "love": "‚ù§Ô∏è",
    "cat": "üê±", "dog": "üê∂", "coffee": "‚òï"
})

words = ["I", "love", "coffee"]
result = []
for w in words:
    emoji = word_to_emoji[w.lower()]
    if emoji:
        result.append(emoji)
    else:
        result.append(w)

print(" ".join(result))  
```

## Beyond Caesar: Random Substitution

A Caesar cipher shifts by a fixed amount ‚Äî we can decode with math:

```python
plain_letter = chr(ord('A') + (i - shift) % 26)
```

But what if the spy used a **random substitution**? No formula can help!

``` {pyodide}
# A random cipher ‚Äî no pattern, just memorize the mapping
decrypt = {
    "X": "A", "W": "B", "E": "C", "R": "D", "Z": "E",
    "Y": "F", "M": "G", "Q": "H", "P": "I", "J": "J",
    "K": "K", "S": "L", "D": "M", "F": "N", "G": "O",
    "H": "P", "B": "Q", "L": "R", "V": "S", "T": "T",
    "U": "U", "C": "V", "N": "W", "A": "X", "O": "Y", "I": "Z"
}
print(decrypt)
```

## Decoding with the Mapping

``` {pyodide}
secret_message = "QXCZ X MLZXT LZXRPFM WLZXK"

decoded = ""
for char in secret_message:
    if char.isalpha():
        decoded += decrypt[char]  # Dictionary maps cipher ‚Üí plain
    else:
        decoded += char

print("Decoded:", decoded)
```

The dictionary *is* the cipher ‚Äî no formula, just lookup!

## Let's Practice! {.activity}

Open today's activity. You'll solve 2 new puzzles.

[PrairieLearn Activity](https://us.prairielearn.com/pl/course_instance/202804/assessment/2641280)

## Summary

Dictionaries give you **fast lookup by key** ‚Äî whether you have 100 items or 100,000.

| Pattern | Use Case | Technique |
|---------|----------|-----------|
| **Record** | Store named fields | `{"name": ..., "age": ...}` |
| **Membership** | Track what we've seen | `seen[x] = True` |
| **Counting** | Count occurrences | `Counter(items)` |
| **Complement** | Find pairs | Store & check complements |
| **Grouping** | Organize by category | `defaultdict(list)` |
| **Translation** | Convert values | Direct key ‚Üí value mapping |

## Next Week

**Reading Week ‚Äî No Classes!**

Enjoy the break, and keep working on Project 1.

See you in Week 8!
