---
date: 2026-01-27
---

## Announcements

## Quick recap: Dataclasses {.smaller}

A **dataclass** bundles related data together into a custom type.

``` {pyodide}
from dataclasses import dataclass

@dataclass
class Bead:
    radius: float
    colour: tuple[int, int, int]  # RGB

    def diameter(self) -> float:
        return 2 * self.radius
```

- **Attributes**: data stored in the object (`radius`, `colour`)
- **Methods**: functions that belong to the class (`diameter`)

## A bead bracelet

![](/images/bracelet.png){.r-stretch fig-alt="A colorful beaded bracelet."}

What data describes a **bead**?

What data describes a **bracelet**?

::: notes
Bead: radius, color
Bracelet: radius, list of beads
:::

## The Bracelet

A bracelet contains **a list of beads** and has a **radius**.

``` {pyodide}
@dataclass
class Bracelet:
    radius: float           # radius of the bracelet circle
    beads: list[Bead]       # the beads on the bracelet
```

This is **composition**: a Bracelet *contains* Beads.

## Creating a Bracelet

``` {pyodide}
@dataclass
class Bracelet:
    radius: float           # radius of the bracelet circle
    beads: list[Bead]       # the beads on the bracelet

# First, create some beads
b1 = Bead(radius=5.0, colour=(255, 0, 0))
b2 = Bead(radius=3.0, colour=(0, 255, 37))
b3 = Bead(radius=4.0, colour=(0, 0, 255))

# Create a bracelet with those beads
# Access the beads inside the bracelet

```

## Does it fit?

![](/images/bracelet_fits.png){.r-stretch}

The beads fit on the bracelet if the sum of their diameters is less than or equal to the circumference. We refer to the extra string as *slack*.

## How much slack?

``` {pyodide}
import math

@dataclass
class Bracelet:
    radius: float
    beads: list[Bead]

    def circumference(self) -> float:
        return 2 * math.pi * self.radius

    def slack(self) -> float:
    """ circumference - sum of diameters"""
        pass
```

## Adding beads safely

We only want to add a bead if it fits!

``` {pyodide}
@dataclass
class Bracelet:
    radius: float
    beads: list[Bead]

    def circumference(self) -> float: ...
    def slack(self) -> float: ...

    def string_bead(self, bead: Bead) -> bool:
        """Add a bead only if it fits. Returns True if added."""
        pass
```

## Removing beads

What if we want to swap out a bead?

``` {pyodide}
@dataclass
class Bracelet:
    ...
    def remove_bead(self, index: int) -> Bead:
        """Remove and return the bead at the given index."""
        pass
```

**Hint:** Lists have a method called `pop(index)` that removes and returns the item at that index.

``` {pyodide}
fruits = ["apple", "banana", "cherry"]
removed = fruits.pop(1)  # removes "banana"
print(removed)           # "banana"
print(fruits)            # ["apple", "cherry"]
```

## Drawing the bracelet

![](/images/bracelet_layout.png){.r-stretch}

## The full picture {.smaller}

``` python
@dataclass
class Bead:
    radius: float
    colour: tuple[int, int, int]

    def diameter(self) -> float: ...
    def draw(self, ax, x: float, y: float) -> None: ...

@dataclass
class Bracelet:
    radius: float
    beads: list[Bead]

    def circumference(self) -> float: ...
    def slack(self) -> float: ...
    def string_bead(self, bead: Bead) -> bool: ...
    def remove_bead(self, index: int) -> Bead: ...
    def draw(self) -> None: ...
```

## {{< iconify fa6-solid computer >}} Your turn: Implement Bracelet {.activity}

Try the [**Bracelet Activity**](https://us.prairielearn.com/pl/course_instance/202804/assessment/2640487) on PrairieLearn!

Implement these methods:

- `circumference()` - return 2Ï€r
- `slack()` - circumference minus total bead diameters
- `string_bead(bead)` - add bead if it fits, return True/False
- `remove_bead(index)` - remove and return the bead at index

If you finish early, try **Tasks 4 & 5** (brighten methods)!

{{< countdown minutes=30 >}}

## Extending functionality: Name bracelets

What if we want to make a **friendship bracelet** with someone's name on it?

![](/images/name-bracelet.svg){.r-stretch fig-alt="A bracelet with letter beads spelling CS203."}

We need beads that can hold **letters**!

## Adding letters to beads

Let's add an optional `letter` attribute to our Bead class:

``` {pyodide}
@dataclass
class Bead:
    radius: float
    colour: tuple[int, int, int]
    letter: str = ""  # empty string means no letter

    def diameter(self) -> float:
        return 2 * self.radius
```

Now beads can optionally have letters!

``` {pyodide}
plain_bead = Bead(radius=3.0, colour=(255, 0, 0))           # no letter
letter_bead = Bead(radius=3.0, colour=(255, 0, 0), letter="C")  # has letter
```

## Python's `enumerate()` function

When iterating over a list, sometimes you need both the **index** and the **value**:

``` {pyodide}
fruits = ["apple", "banana", "cherry"]

# Without enumerate - manually tracking index
i = 0
for fruit in fruits:
    print(f"{i}: {fruit}")
    i += 1

# With enumerate - cleaner!
for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")
```

`enumerate()` gives you pairs of `(index, value)` as you loop.

## Naming a bracelet

Add a `name()` method to Bracelet that assigns letters to existing beads:

``` {pyodide}
def name(self, word: str) -> None:
    """Assign letters from REVERSED word to the first beads."""
    for i, letter in enumerate(reversed(word)):
        if i < len(self.beads):
            self.beads[i].letter = letter
            # Lighten the bead (blend toward white)
            r, g, b = self.beads[i].colour
            self.beads[i].colour = (
                min(255, r + 2*(255 - r) // 3),
                min(255, g + 2*(255 - g) // 3),
                min(255, b + 2*(255 - b) // 3),
            )
```

Why `reversed`? So the name reads correctly around the circle!

## Using `name()`

``` {pyodide}
# Create a bracelet with some beads
b1 = Bead(radius=3.0, colour=(255, 0, 0))
b2 = Bead(radius=3.0, colour=(0, 255, 0))
b3 = Bead(radius=3.0, colour=(0, 0, 255))
bracelet = Bracelet(radius=20.0, beads=[b1, b2, b3])

# Name it!
bracelet.name("HI")

# Check the letters (reversed order!)
print(bracelet.beads[0].letter)  # "I"
print(bracelet.beads[1].letter)  # "H"
print(bracelet.beads[2].letter)  # "" (no letter assigned)
```

## {{< iconify fa6-solid computer >}} Your turn: Letter beads {.activity}

Back to PrairieLearn - try **Task 6: Letter Beads**!

{{< countdown minutes=15 >}}

## Design Strategies

1.  Identify the **objects** in your problem (nouns)

2.  List the **data** each object needs (attributes)

3.  List the **operations** each object supports (methods)

4.  Decide which object is responsible for what

5.  Implement and test incrementally

## What you learned

- **Dataclasses** let us define custom types with attributes
- **Methods** are functions that belong to a class
- **Composition**: objects can contain other objects
- **Design**: who owns what data and behavior matters!
