---
date: 2026-01-20
---

## Announcements

## {{< iconify fa6-solid computer >}} List Activity {.activity}

Let's explore some surprising list behaviors.

Open the [**List Activity**](https://us.prairielearn.com/pl/course_instance/202804/assessment/2638038) on PrairieLearn.

Inside the workspace there are 4 files, each containing a short sequence of exercises. Complete them, and then we'll review together.

Be curious. Feel free to experiment by changing things!

Write down surprising behaviors.

{{< countdown minutes=10 >}}

::: notes
Week3_tue_lists activity - covers aliasing, append vs extend, list comprehension
:::

## Lists: A Quick Review

Lists are **ordered collections** that can hold any type of data.

``` {pyodide}
provinces = ['British Columbia', 'Alberta', 'Ontario']
numbers = [1, 2, 3, 4, 5]
mixed = ['hello', 42, 3.14, True]
```

We can:

- Access elements by index: `provinces[0]`
- Slice: `numbers[1:3]`
- Get length: `len(provinces)`

## Adding to Lists

``` {pyodide}
provinces = ['British Columbia']

# These work differently!
provinces.append('Alberta')           # adds one element
provinces.extend(['Ontario', 'Quebec'])  # adds each element

maritime = provinces + ['NS']         # new list!
provinces[0] = 'BC'
print(maritime[0])                    # still 'British Columbia'
```

What about `provinces.append(['Ontario', 'Quebec'])`?

## List Aliasing

``` {pyodide}
grid = [[1, 2], [3, 4]]
backup = grid

grid[0][0] = 99

print(grid)      # [[99, 2], [3, 4]]
print(backup)    # [[99, 2], [3, 4]] -- surprise!
```

Assignment doesn't copy lists -- it creates another **reference** to the same list.

## Shallow Copy

``` {pyodide}
grid = [[1, 2], [3, 4]]
backup = grid.copy()     # shallow copy - NEW outer list

grid[0][0] = 99

print(grid)      # [[99, 2], [3, 4]]
print(backup)    # [[99, 2], [3, 4]] -- still linked!
```

`.copy()` only copies the outer list. The inner lists are still shared!

## Deep Copy

``` {pyodide}
import copy

grid = [[1, 2], [3, 4]]
backup = copy.deepcopy(grid)   # copies EVERYTHING

grid[0][0] = 99

print(grid)      # [[99, 2], [3, 4]]
print(backup)    # [[1, 2], [3, 4]] -- truly independent!
```

Use `deepcopy` when you have nested structures (lists of lists, lists of objects).

## References

Variables are **names** that refer to objects in memory.

``` {pyodide}
m1 = ['a', 'b']    # m1 refers to a list object
m2 = m1            # m2 refers to the SAME object
m3 = m1.copy()     # m3 refers to a NEW object (shallow)
```

Think of it like sticky notes on boxes - `m1` and `m2` are two sticky notes on the **same** box.

## List Comprehensions

A compact way to create lists:

``` {pyodide}
# Instead of this:
squares = []
for x in range(5):
    squares.append(x ** 2)

# Write this:
squares = [x ** 2 for x in range(5)]
```

Both produce: `[0, 1, 4, 9, 16]`

## List Comprehensions with Conditions

``` {pyodide}
# Filter: only include if condition is true
evens = [x for x in range(10) if x % 2 == 0]
# [0, 2, 4, 6, 8]

# Transform based on condition
signs = [x if x % 2 == 0 else -x for x in range(5)]
# [0, -1, 2, -3, 4]
```

Notice the difference: `if` at the **end** filters, `if/else` **before** `for` transforms.

## What you learned

- **Aliasing**: assignment creates references, not copies
- **Shallow copy**: `.copy()` only copies the outer structure
- **Deep copy**: `copy.deepcopy()` copies everything
- **List comprehensions**: compact syntax for creating lists
