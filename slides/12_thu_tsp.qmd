---
date: 2025-11-25
---

## Announcements

# Travelling Salesperson Problem

## TSP vs SSSP {data-background-image="/images/maps1data.png"}

SSSP: â€œmany one-way routes from home (tree)â€ vs TSP: â€œone big round trip through everyone (loop)â€

## TSP vs SSSP {.smaller}

| Aspect | SSSP (Single-Source Shortest Paths) | TSP (Travelling Salesperson) |
|--------|-------------------------------------|------------------------------|
| Goal | Shortest route from one start to **each** vertex | One **cheapest tour** visiting all vertices and returning |
| Shape | **Tree** of paths from the source | **Cycle** through all vertices |
| Must visit all? | No â€“ each path can **skip** most vertices | Yes â€“ must **visit every** vertex exactly once |
| Overlap | Paths often **share edges** | Tour is one sequence; no repeated visits |
| Difficulty | Fast algorithms (e.g., Dijkstra) | NP-hard; exact solution is hard for large graphs |


## Demo Blog

<https://medium.com/data-science/around-the-world-in-90-414-kilometers-ce84c03b8552>

![](/images/maps9caps.png)

## Plan for Code {data-background-image="/images/maps9chart.png"}

Steps to assemble our solution:

\ 

1. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

2. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

3. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

4. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

5. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

::: notes
1. assemble the graph and errands
2. create pairwise distances
3. create all possible permutations of paths
4. find minimum route and assemble turn-by-turn for that route
5. visualize on map
:::

## A Technical Detail

![](/images/maps9home.png)

## Demo {.activity}

[PrairieLearn Activity](https://us.prairielearn.com/pl/course_instance/193300/assessment/2616092)

## What Does `lambda` Do? {.smaller}

``` python
dferrands['latlong'] = dferrands.apply(
                lambda row: ox.geocode(row['errand']),
                axis=1
              )
```

**Goal:** Create a new column (`latlong`) and fill it with coordinates for each errand in the dataframe.

**How it works:**

* `df.apply(..., axis=1)`:  Run a function once for each row.

* `lambda row: ox.geocode(row['errand'])`: A tiny inline function. Read it as:
"Given a row, look up the place name in `row['errand']`,geocode it, and return the (lat, lon)."

* The returned value becomes the entry in the new latlong column.

**Why lambda?** We only need this function once, so we write it right where itâ€™s used.

## Tour Distance

We assemble each candidate solution as an arrangement of all of the errands:

Ex: `A D B E F C`

How do we find the total distance if we do the errands in the suggested order?

## Why This Matters {.smaller}

There are *lots* of applications:

- ğŸ“¦ **UPS/FedEx/Amazon Delivery** Millions saved by reducing even 1km per driver per day.
- ğŸ” **UberEats/DoorDash/Skip** Multi-stop pickup/delivery with time windows.
- ğŸ§¬ **DNA Sequencing & Genome Assembly** Ordering fragments relies on TSP-like reconstruction.
- ğŸšŒ **School Bus Routing** Minimize buses, fuel, and time while meeting constraints.
- ğŸ§ª **Medical Lab Sample Pipelines** Robotic arms schedule efficient multi-station workflows.
- â„ï¸ **Snowplow & Garbage Truck Routing** Efficiently cover every street in a city.
- ğŸ­ **Factory Robots & CNC Machines** Optimizing tool paths reduces waste, heat, and wear.
- âœˆï¸ **Airline Crew Scheduling** Complex daily routing: crews must return to base, meet rest rules.
- ğŸŒ **City Infrastructure Planning** Utility inspections, meter reading, streetlight repair routes.
- ğŸš‘ **Ambulance & Emergency Routing** Minimize response times; life-critical optimization.

